package merkle.implementation;

import merkle.Configuration;
import merkle.IClient;
import merkle.IMerkleTree;

import java.util.List;

/**
 * TASK 2
 * TODO: IMPLEMENT verifyResponse
 *
 * @author Iain Woodburn
 * @pso 17
 * @date 25-Oct-2016
 */
public class Client extends IClient {

    /**
     * Given the path siblings this function has to verify if
     * the masterHash generated by concatenating and hashing
     * level by level is the same as <i>this.masterHash</i>
     * You can use <i>Configuration.hashFunction</i>
     */
    protected boolean verifyResponse(List<IMerkleTree.Node> pathSiblings) throws Exception {

        //Continually hashes the first element with each node in the path, while setting the first element to the result of that hash
        for(int i = 1; i < pathSiblings.size(); i++){

          //Ensures that hashing only occurs left then right child
          if(pathSiblings.get(i).getIndex() % 2 != 0){
            pathSiblings.set(0, new IMerkleTree.Node(Configuration.hashFunction.concatenateHash(pathSiblings.get(0), pathSiblings.get(i)), pathSiblings.get(0).getIndex() / 2));
          } else {
            pathSiblings.set(0, new IMerkleTree.Node(Configuration.hashFunction.concatenateHash(pathSiblings.get(i), pathSiblings.get(0)), pathSiblings.get(0).getIndex() / 2));
          }
          
        }

        //Gets the final hash value from the first element
        String serverHash = pathSiblings.get(0).getHash();

        return serverHash.equals(this.masterHash);
    }
}
